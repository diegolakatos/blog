<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Diego Lakatos</title>
    <link>http://localhost:1313/pt-br/</link>
    <description>Recent content on Diego Lakatos</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Sat, 12 Feb 2022 12:33:53 +0000</lastBuildDate><atom:link href="http://localhost:1313/pt-br/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Nem sempre é DNS, diversão com proxies, AWS IAM roles e uma pitada de Terraform</title>
      <link>http://localhost:1313/pt-br/posts/aws-metada-service-with-proxy/</link>
      <pubDate>Sat, 12 Feb 2022 12:33:53 +0000</pubDate>
      
      <guid>http://localhost:1313/pt-br/posts/aws-metada-service-with-proxy/</guid>
      
      <description>&lt;p&gt;Há um tempo atrás, enquanto trabalhava em um pipeline que seria usado para criar recursos na AWS, enfrentei uma situação inusitada que me levou a uma investigação bastante interessante.&lt;/p&gt;
&lt;p&gt;O cenário era bem simples, uma instância do EC2 atuando como um &lt;a href=&#34;https://docs.gitlab.com/runner/&#34;&gt;gitlab-runner&lt;/a&gt; executando um contêiner Docker que baixaria um código Terraform do nosso repositório e executaria &lt;code&gt;terraform apply&lt;/code&gt;. A instância do EC2 tinha uma IAM role anexada com todas as permissões necessárias para criar os recursos definidos no código do Terraform.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Sobre</title>
      <link>http://localhost:1313/pt-br/pages/about/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/pt-br/pages/about/</guid>
      
      <description>&lt;p&gt;Olá, meu nome é Diego Verissimo Lakatos e neste blog espero compartilhar meus conhecimentos e também aprender coisas novas.
Minhas áreas de interesse são computação em nuvem, containers, Linux e infraestrutura como código.
No meu tempo livre gosto de ler, assistir filmes e jogar videogame.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Usando Terraform Para Gerenciar Kubernetes</title>
      <link>http://localhost:1313/pt-br/posts/using-terraform-to-manage-kubernetes/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/pt-br/posts/using-terraform-to-manage-kubernetes/</guid>
      
      <description>&lt;p&gt;Ao trabalhar com kubernetes, a maneira padrão de criar objetos tais quais &lt;em&gt;pods&lt;/em&gt;, &lt;em&gt;deployments&lt;/em&gt; e &lt;em&gt;services&lt;/em&gt; é criar um arquivo de manifesto, normalmente em yaml, que descreva o estado desejado e, em seguida, usar &lt;code&gt;kubectl&lt;/code&gt; para realizar a criação ou atualização o objeto.&lt;/p&gt;
&lt;p&gt;Apesar de tudo, esse processo simples pode criar uma barreira para desenvolvedores e equipes de operações que agora precisam manter uma nova base de código em uma nova &amp;ldquo;linguagem&amp;rdquo;. O YAML é fácil de ler, mas solucionar o problema pode ser difícil devido à necessidade de identificação correta e os erros exibidos pelo &lt;code&gt;kubectl&lt;/code&gt; podem não ser facilmente compreendidos.
Se uma equipe já está usando o Terraform para criar e gerenciar a infraestrutura, faz sentido usá-lo para criar os objetos dentro do kubernetes, isso traz algumas vantagens, como:&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
